#!/usr/bin/env ruby

require 'yaml'
require 'encryptor'
require 'digest'
require 'highline'

class Digestor
  # Generates a password from a
  # given master password and key
  # This is a stub interface

  def initialize(username,password)
    # You should probably generate
    # some intermediate data with these
  end

  def make_password_int(key)
    # Return a giant integer deterministically
    # built from the username/password/key combo.
  end
end

class SHA512Digestor
  # Old digestor from before I knew what I was doing
  # Probably a bad idea to use (esp. if your master
  # password is weak and/or an adversary has root).

  def initialize(username,password)
    @password_hash = Digest::SHA512.hexdigest(password).to_i(16)
  end

  def make_password_int(key)
    Digest::SHA512.hexdigest(key).to_i(16) ^ @password_hash
  end
end

class PasswordRepo

    class PasswordGenerator
        
        ATTRIBUTES = [:character_set, :length, :suffix]

        attr_reader(*ATTRIBUTES)
        
        CHARACTER_SET = (0x21..0x7E).collect(&:chr)

        def self.valid_regex(rgx)
            return CHARACTER_SET.any?{|s| rgx.match(s)}
        end

        def initialize(hsh)
            if @character_set = hsh[:character_set]
            elsif ch_rgx = hsh[:character_regex]
                raise ArgumentError.new("Your regex matches no characters") unless PasswordGenerator.valid_regex(ch_rgx)
                @character_set = CHARACTER_SET.select{|a| ch_rgx.match(a)}.sort.join
            else
                raise ArgumentError.new("Need :character_set or :character_regex")
            end
            (@length = hsh[:length]) || (raise ArgumentError.new("Need :length"))
            @suffix = hsh[:suffix] || ''
        end

        def generate(hashed)
            base = @character_set.size
            pass = []
            @suffix ||= ''
            until((pass.size + @suffix.size) == @length)
                hashed, m = hashed.divmod(base)
                pass << @character_set[m]
            end
            pass.join + @suffix
        end
    end

    DEFAULT_OPTIONS = {
        :passwords_file => "#{ENV['HOME']}/.saved_passwords.yaml",
        :digestor => SHA512Digestor,
    }

    attr_reader :key_list

    class MissingKeyError < ArgumentError
        def initialize(key)
            super("Key #{key} does not exist in the set. Create it first.")
        end
    end

    class InvalidPasswordError < ArgumentError
        def initialize
            super("The provided password could not be used to read the file.")
        end
    end

    def initialize(username, password, options={})
        options = DEFAULT_OPTIONS.merge(options)
        @key_list = {}
        @password_file = options[:passwords_file]
        if File.exists?(@password_file)
            @key_list.merge!(YAML.load(File.open(@password_file, 'rb'){|f| f.read}))
        end
        @digestor = options[:digestor].new(username, password)
        write
    end

    def write
        File.open(@password_file, 'wb') do |file|
            file.write(@key_list.to_yaml)
        end
    end

    def add_entry(key, generator)
        @key_list[key] = generator
        write
        password(key)
    end

    def remove_entry(key)
        @key_list.delete(key)
        write
    end

    def password(key)
        (generator = @key_list[key]) || (raise MissingKeyError(key))
        hashed = @digestor.make_password_int(key)
        generator.generate(hashed)
    end
end

class UserPrompt < HighLine
    def main_menu
        continue = true
        begin
            system("reset")
            @password_repo || (load_password_file; redo)
            choose do |menu|
                menu.prompt = "Pick an action. "
                menu.choice("List Passwords"){say(@password_repo.key_list.keys.join("\n"))}
                menu.choice("Add Password"){add_password}
                menu.choice("Show Password"){show_password}
                menu.choice("Remove Password"){remove_password}
                menu.choice("Quit"){continue = false}
                menu.readline = true
            end
            ask("Press Enter to continue") if continue
        rescue Interrupt
            say("Quitting")
            continue = false
        end while continue
    end
    
    def load_password_file
        begin
            username = ask("Username? ")
            password = ask("Password? "){|q| q.echo = false}
            @password_repo = PasswordRepo.new(username,password)
        rescue PasswordRepo::InvalidPasswordError => e
            say("The password is invalid.")
            retry
        end
    end

    def add_password
        key = ask("Key for password: "){|q| q.validate = /\w+/}
        if @password_repo.key_list[key]
            agree("This will override an existing password, are you sure? ") or return
        end
        length = ask("Length of password (including suffix): ", Integer){|q| q.above=0}
        regex = ask("Allowed Characters (Regex): ", Regexp) do |q|
            q.default = '.'
            q.validate = lambda {|s| PasswordRepo::PasswordGenerator.valid_regex(Regexp.new(s))}
            q.responses[:not_valid] = "Your regex must match at least 1 character in ASCII Printable range."
        end
        suffix = ask("Suffix: ") do |q|
            q.default = nil
            q.validate = lambda{|s| s.length < length}
            q.responses[:not_valid] = "Your suffix must be shorter than #{length}."
        end
        return unless agree(<<-PROMPT)
Use these settings?
Key:              #{key}
Length:           #{length}
Character_regex:  #{regex}
Suffix:           #{suffix}
        PROMPT
        created_password = @password_repo.add_entry(key, PasswordRepo::PasswordGenerator.new(:length => length, :character_regex => regex, :suffix => suffix))
        say("Done, your new password is\n#{created_password}")
    end

    def show_password
        choose do |menu|
            menu.prompt = "Which password? "
            menu.choice('cancel'){}
            menu.choices(*@password_repo.key_list.keys) do |key|
                password = @password_repo.password(key)
                parameters = @password_repo.key_list[key]
                say("Password:\n#{password}")
                say("Generated with:\n\tLength: #{parameters.length}\n\tSuffix: #{parameters.suffix}\n\tCharacter Set: #{parameters.character_set}")
            end
            menu.readline = true
        end
    end

    def remove_password
        choose do |menu|
            menu.prompt = "Which password? "
            menu.choices(*@password_repo.key_list.keys) do |key|
                @password_repo.remove_entry(key)
                say("Deleted")
            end
            menu.readline = true
        end
    end
end

if __FILE__ == $PROGRAM_NAME
  UserPrompt.new.main_menu
end
